// Scan pkg/src/data/precomputed and generate pkg/src/data/manifest.ts
// with static import() switch statements for bundler-friendly embedding.

import { promises as fs, constants as FS_CONSTANTS } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const pkgDir = resolve(__dirname, '..');
const precomputedDir = resolve(pkgDir, 'src', 'data', 'precomputed');
const outFile = resolve(pkgDir, 'src', 'data', 'manifest.ts');

const KNOWN_TYPES = ['new_moons', 'solar_terms', 'full_moons'];

async function exists(path) {
  try {
    await fs.access(path, FS_CONSTANTS.F_OK);
    return true;
  } catch {
    return false;
  }
}

async function listYears(dir) {
  if (!(await exists(dir))) return [];
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const years = [];
  for (const e of entries) {
    if (!e.isFile()) continue;
    if (!e.name.endsWith('.json')) continue;
    const base = e.name.slice(0, -5);
    const n = Number(base);
    if (Number.isInteger(n)) years.push(n);
  }
  years.sort((a, b) => a - b);
  return years;
}

function generateSwitchForType(dataType, years) {
  if (years.length === 0) return `// No data for ${dataType}\n`;
  const cases = years
    .map(
      (y) =>
        `        case ${y}: return (await import('./precomputed/${dataType}/${y}.json')).default;`
    )
    .join('\n');
  return `
    case '${dataType}':
      switch (year) {
${cases}
      }
      break;`;
}

function generateManifestSource(typesToYears) {
  const presentTypes = Object.keys(typesToYears).filter((t) => typesToYears[t].length > 0);
  const union = presentTypes.length > 0 ? presentTypes.map((t) => `'${t}'`).join(' | ') : `'new_moons' | 'solar_terms' | 'full_moons'`;
  const switches = presentTypes.map((t) => generateSwitchForType(t, typesToYears[t])).join('\n');

  return `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-data-manifest.mjs
// Maps (dataType, year) => static JSON import for bundlers.

export type DataType = ${union};

export async function loadData(dataType: DataType, year: number): Promise<any> {
  switch (dataType) {
${switches}
  }
  throw new Error(\`No static data for \${dataType}/\${year}\`);
}
`;
}

async function main() {
  if (!(await exists(precomputedDir))) {
    console.warn(`[generate-data-manifest] Source not found: ${precomputedDir} - creating placeholder.`);
    const placeholder = `// Generated at build time by scripts/generate-data-manifest.mjs
// Placeholder manifest - no data found under precomputed/.

export type DataType = 'new_moons' | 'solar_terms' | 'full_moons';
export async function loadData(_dataType: DataType, _year: number): Promise<any> {
  throw new Error('Static data manifest not generated: no precomputed data found.');
}
`;
    await fs.mkdir(dirname(outFile), { recursive: true });
    await fs.writeFile(outFile, placeholder, 'utf-8');
    return;
  }

  const typesToYears = {};
  for (const t of KNOWN_TYPES) {
    const d = resolve(precomputedDir, t);
    typesToYears[t] = await listYears(d);
  }

  const src = generateManifestSource(typesToYears);
  await fs.mkdir(dirname(outFile), { recursive: true });
  await fs.writeFile(outFile, src, 'utf-8');

  const summary = Object.entries(typesToYears)
    .map(([t, ys]) => `${t}:${ys.length}`)
    .join(', ');
  console.log(`[generate-data-manifest] Wrote manifest with types: ${summary}`);
}

main().catch((err) => {
  console.error('[generate-data-manifest] Error:', err);
  process.exit(1);
});